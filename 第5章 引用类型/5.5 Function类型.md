# 5.5 Function类型

- JS中的函数实际上是对象，每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。
  - 由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。
  - 函数通常是使用函数声明语法定义的。
    ```js
    function sum (num1, num2) {
      return num1 + num2;
    }
    // 下面使用函数表达式定义函数的方式和函数声明相差无几。

    var sum = function(num1, num2) {
      return num1 + num2;
    }
    ```
  - 在使用函数表达式定义函数时，没有必要使用函数名，通过变量名就可以引用函数。
    - 注意函数末尾有一个分号，就像声明其他变量时一样。
  - 最后一种定义函数的方式是使用Function构造函数，可以接收任意数量的参数，但最后一个参数始终都会被看成是函数体，前面的参数则枚举出新函数的参数。

    `var sum = new Function("num1", "num2", "return num1 + num2");  //不推荐`
    - 从技术角度来说，这是一个函数表达式，但这种语法会导致解析两次代码，第一次是解析常规JS代码，第二次是解析传入构造函数中的字符串；影响性能。
      - 但这种语法便于理解”函数是对象，函数名是指针"的概念。
  - 函数名与包含对象指针的其他变量没什么区别，一个函数可能会有多个名字。
  - 使用不带圆括号的函数名是访问函数指针，而非调用函数。

## 5.5.1 没有重载（深入理解）

- 将函数名想象成指针，有助于理解为什么JS中没有函数重载的概念。
  - 在创建第二个同名函数时，会覆盖第一个函数。

## 5.5.2 函数声明与函数表达式

- 解析器在向执行环境加载数据时，对函数声明和函数表达式并非一视同仁。
  - 解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）。
  - 函数表达式必须等到解析器执行到它所在的代码行，才会真正被解释执行。
    - 代码在开始执行之前，解析器就已经通过了函数声明提升，读取并将函数声明添加到执行环境中。
      - 对代码求值时，JS引擎在第一遍会声明函数并将它们放到源代码树的顶部。即使声明函数的代码在调用它的代码后面，JS引擎也能把函数声明提升到顶部。
    - 函数位于一个初始化语句中，在执行到函数所在的语句之前，变量名中不会保存有对函数引用。
  - 除了什么时候可以通过变量访问到函数这一点的区别，函数声明与函数表达式的语法是等价的。
> 可以同时使用函数声明和函数表达式，例如var sum = function sum(){}.但是这种语法在Safari中会导致错误。

## 5.5.3 作为值的函数

- 因为JS中的函数名本身就是变量，所以函数也可以作为值来使用。
  - 不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的的结果返回。
    ```js
    function createComparisonFunction(propertyName) {
      return function(object1, object2) {
        var value1 = object1[propertyName];
        var value2 = object2[propertyName];

        if (value1 < value2) {
          return -1;
        } else if (value1 > value2) {
          return 1;
        } else {
          return 0;
        }
      };
    }
    ```
    - 上面这个例子就是利用了从一个函数中返回另一个函数的技术，从而达到根据某个对象属性对数组进行排序的目的。
      - 这个函数实际上就是在函数内部嵌套了另一个函数，且前面加了一个return操作符；在内部函数接收到propertyName参数后，就会使用方括号表示法来取得给定属性的值，之后定义比较函数就非常简单了。

## 5.5.4 函数内部属性

- 函数内部有两个特殊对象:arguments和this。
  - arguments是一个类数组对象，包含着传入函数中的所有参数。
    - 这个对象还有一个名叫callee的属性，是一个指针，指向拥有这个arguments对象的函数。
      - 定义阶乘函数一般都要用到递归算法。
        ```js
        function factorial (num) {
          if (num <= 1) {
            return 1;
          } else {
            return num * factorial(num - 1);
          }
        }
        ```
      - 以上代码在函数有名字且名字以后也不会便的情况下，这样定义没有问题，但是这个函数的执行与它的函数名紧紧耦合在了一起。而callee这个属性就可以消除这种紧密耦合的现象。
        ```js
        function factorial (num) {
          if (num <= 1) {
            return 1;
          } else {
            return num * arguments.callee(num - 1);
          }
        }
        ```
      - 这样无论引用函数时使用的是什么名字，都可以保证正常完成递归调用。
- 函数内部的另一个特殊对象是this，它引用的是函数据以执行的环境对象——或者说就是this值（当在网页的全局作用域中调用函数时，this对象引用的就是window)。
  - 在调用函数之前，this的值并不确定，它可能会在代码执行过程中引用不同的对象。
> 函数的名字仅仅是一个包含指针的变量而已。

- ES5也规范化了另一个函数对象的属性:caller。这个属性中保存着调用当前函数的函数的引用。如果在全局作用域中调用当前函数，它的值为null。

- 函数在严格模式下访问arguments.callee会导致错误，访问arguments.caller也会导致错误，在非严格模式下这个属性始终是undefined。
  - 定义这个属性是为了分清arguments.caller和函数的caller属性。
  - 严格模式下也不能为函数的caller属性赋值。
  
## 5.5.5 函数属性和方法

- ES中的函数是对象，因此函数也有属性和方法。每个函数都包含两个属性:length和prototype。
  - length属性表示函数希望接收的命名参数的个数。
  - prototype属性被用来保存引用类型的所有实例方法。
    - 诸如toString()和valueOf()等方法实际上都保存在prototype名下，但是是通过各自对象的实例来访问。
    - 创建自定义引用类型以及实现继承时，prototype属性的作用很重要。
    - ES5中，prototype属性不可枚举，因此使用for-in无法发现。
- 每个函数都包含两个非继承而来的方法: apply()和call()。
  - 用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。
  - apply()方法接收两个参数:一个是在其中运行函数的作用域，另一个是参数数组。
    - 第二个参数可以是Array的实例，也可以是arguments对象。
  > 严格模式下，未指定环境对象而调用函数，则this值不会转型为window。除非明确把函数添加到某个对象或者调用apply()或call()，否则this值将是undefined.
  - call()方法与apply()方法的作用相同，它们的区别仅在于接收参数的方式不同。
    - call()方法的第一个参数还是this值，但是其余参数都是直接传递给函数。
      - 在使用call()方法时，传递给函数的参数必须逐个列举出来。
      - apply()和call()的结果没有什么不同，取决于你采取哪种给函数传递参数的方式最方便。
        - 如果打算直接传入arguments对象，或者包含函数中先接收到的也是一个数组，那么使用apply()函数更方便，反之选择call()会更合适。
        - 在不给函数传递参数的情况下，使用哪个方法都一样。
  - apply()方法和call()方法还能够扩充函数赖以运行的作用域。
    - 使用它们来扩充作用域的最大好处就是对象不需要与方法有任何耦合关系。
- ES5还定义了一个方法: bind()。这个方法会创建一个函数的实例，其this值会被绑定到传给bind()函数的值。
    ```js
    window.color = "red";
    var o = { color："blue" };

    function sayColor() {
      console.log(this.color);
    }
    var objectSayColor = sayColor.bind(o);
    objectSayColor();  //blue
    ```
  - 在上面的例子中，即使在全局作用域中调用这个函数，也会返回"blue"。
- 每个函数继承的toLocaleString()和toString()方法始终都返回函数的代码。
  - 返回的格式则因浏览器而异。
  - 这些信息在调式代码时会比较有用。
- 另一个继承的valueOf()方法同样也只返回函数代码。