# 5.4 RegExp类型

- JS通过RegExp类型来支持正则表达式。
  `var expression = / pattern / flags ;`
- 其中的模式(pattern)部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。
  - 每个正则表示式都可带有一个或多个标志(flags),用以标明正则表达式的行为。
  - 正则表达式的匹配模式支持下列3个标志:
    - g: 表示全局(global)模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止。
    - i: 表示不区分大小写模式，在确定匹配项时忽略模式与字符串的大小写。
    - m: 表示多行(multiline)模式，在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。
  - 一个表达式就是一个模式与上述3个标志的组合体，不同组合产生不同结果。
  - 模式中使用的所有**元字符**都必须转义。正则表达式中的元字符包括:( [ { \ ^ $ | ) ? * + . } ]
    - 如果想要匹配字符串中包含的这些字符，就必须对它们进行转义。
- 可以使用字面量形式来定义正则表达式，还可以使用RegExp构造函数来创建正则表达式。
  - 它接收两个参数：一个是要匹配的字符串模式，另一个是可选的标志字符串。
  - 可以使用字面量定义的任何表达式，都可以使用构造函数来定义。
      ```js
      /*
       * 匹配第一个"bat"或"vat",不区分大小写
       */
       var pattern1 = /[bc]at/i;

      /*
       * 与pattern1相同，只不过是使用构造函数创建的
       */
       var pattern2 = new RegExp("[bc]at", "i");
       ```
  - 不能把正则表达式字面量传递给RegExp构造函数。
    - 由于RegExp构造函数的模式参数是字符串，所以在某些情况下要对字符进行双重转义。
    - 所有元字符都必须双重转义，那些已经转义过的字符也是一样。

    | 字面量模式 | 等价的字符串 |
    | :------: | :--------: |
    | /\[bc\]at/ | "\\[bc\\]at" |
    | /\.at/ | "\\.at" |
    | /name\/age/ | "name\\/age" |
    | /\d.\d{1,2}/ | "\\d.\\d{1,2}" |
    | /\w\hello\\123/ | "\\w\\\\hello\\\\123" |
> ES5规定使用正则表达式字面量必须像直接调用RegExp构造函数一样，每次都创建新的RegExp实例。

## 5.4.1 RegExp实例属性

- RegExp的每个实例都具有下列属性，通过它们可以取得有关模式的各种信息。
  - global: 布尔值，表示是否设置了g标志。
  - ignoreCase: 布尔值，表示是否设置了i标志。
  - lastIndex: 整数，表示开始搜索下一个匹配项的字符位置，从0算起。
  - multiline: 布尔值，表示是否设置了m标志。
  - source: 正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。
- 字面量和RegExp构造函数的source属性是相同的，这个属性保存的是规范形式的字符串，即字面量形式所用的字符串。
