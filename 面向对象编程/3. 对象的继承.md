# 对象的继承

- A对象通过继承B对象，就能直接拥有B对象的所有属性和方法。
- JS语言的继承不通过class，而是通过原型对象即prototype实现。
  - ES6引进了class语法

## 1.原型对象概述

###　1.1 构造函数的缺点

- JS通过构造函数生成新对象，因此构造函数可以视为对象的模板，实例对象的属性和方法，可以定义在构造函数内部。

  ```js
  function Cat (name, color) {
    this.name = name;
    this.color = color;
  }

  var cat1 = new Cat('大毛', '白色');

  cat1.name // '大毛'
  cat1.color // '白色'
  ```

  - Cat函数是一个构造函数,函数内部定义了name属性和color属性，所有实例对象都会生成这两个属性，即这两个属性会定义在实例对象上面。

- 通过构造函数为实例对象定义属性，有一个缺点，同一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费。

    ```js
    function Cat(name, color) {
      this.name = name;
      this.color = color;
      this.meow = function () {
        console.log("喵喵");
      };
    }

    var cat1 = new Cat("大毛"， "白色");
    vat cat2 = new Cat("二毛", "黑色");

    cat1.meow === cat2.meow //false
    ```

- cat1和cat2是同一个构造函数的两个实例，它们都具有meow方法，由于meow方法是生成在每个实例对象上面，所以两个实例就生成了两次，也就是说，每新建一个实例，就会新建一个meow方法。
  - 这样没有必要，还浪费资源。JS的原型对象prototype就可以解决这个问题

### 1.2 prototype属性的作用

- JS继承机制的设计思想就是原型对象的所有属性和方法，都能被实例对象共享。也就是说如果属性和方法定义在原型上，那么所有实例对象就能共享，不仅节省了内存，还体现了实例对象之间的联系。

- JS规定，每个函数都有prototype属性，指向一个对象。

  ```js
  function f() {
    typeof f.prototype //"object"
  }
  ```

- 上面代码中，函数f默认具有prototype属性，指向一个对象。
- 对于普通函数来说，该属性基本无用，但对于构造函数来说，生成实例的时候，该属性会自动成为实例对象的原型。

  ```js
  function Animal(name) {
    this.name = name;
  }

  Animal.prototype.color = "white";

  var cat1 = new Animal("大毛");
  var cat2 = new Animal("二毛");

  cat1.color //"white"
  cat2.color //"white"
  ```

- 原型对象的属性不是实例对象自身的属性，只要修改原型对象，变动就会立刻体现在所有实例对象上。

  ```js
  Animal.prototype.color = 'yellow';
  cat1.color // "yellow"
  cat2.color // "yellow"
  ```

- 当实例对象本身没有某个属性或方法的时候，它会到原型对象去寻找该属性或方法
  - 如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。

- 原型对象的作用就是定义所有实例对象共享的属性和方法，也是它们被称为原型对象的原因，而实例对象可以视作从原型对象衍生出来的子对象。

  ```js
  Animal.prototype.walk = function () {
    console.log(this.name + "is walking");
  };
  ```

- Animal.prototype对象上定义的walk方法可以在所有Animal实例对象上调用。

### 1.3 原型链

- JS规定所有对象都有自己的原型对象。
  - 任何一个对象都可以充当其他对象的原型
  - 由于原型对象也是对象，所以它也有自己的原型
- 因此这样就会形成一个原型链(prototype chain)
  - 对象到原型，再到原型的原型
- 如果一层层地上溯，所有对象的原型最终都可以上溯到Object.prototype,即Object构造函数的prototype属性
  - 所有对象都继承了Object.prototype属性
  - 这也是所有对象都有valueOf和toString方法的原因
- Object.prototype的原型是null，null没有任何属性和方法，也没有自己的原型。 `Object.getPrototype(Object.prototype) // null`
  - Object.getPrototypeOf方法返回参数对象的原型

- 读取对象的某个属性时，JS引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果直到最顶层的Object.prototype还是找不到，则返回undefined。
  - 如果对象自身和它的原型都定义了一个同名属性，那么优先读取对象自身的属性，这叫做覆盖。
  - 一级级向上，在整个原型链上寻找某个属性，对性能是有影响的，所寻找的属性在越上层的原型对象，对性能的影响越大
    - 如果寻找某个不存在的属性，将会遍历整个原型链

- 如果让构造函数的prototype属性指向一个数组，意味着实例对象可以调用数组方法。

  ```js
  var MyArray = function () {};
  MyArray.prototype = new Array();
  MyArray.prototype.constructor = MyArray;

  var mine = new MyArray();
  mine.push(1, 2, 3);
  mine.length // 3
  mine instanceof Array // ture
  ```

- instanceof表达式用来比较一个对象是否为某个构造函数的实例。

### 1.4 constructor属性

- prototype对象有一个constructor属性，默认指向prototype对象所在的构造函数。

  ```js
  function P() {}
  P.prototype.constructor === P //true
  ```

- constructor属性可以被所有实例对象所继承

  ```js
  function P() {}
  var p = new P();

  p.constructor === P // true
  p.constructor === P.prototype.constructor // true
  p.hasOwnProperty("constructor") // false
  ```

- p是构造函数P的实例对象，但是p自身没有constructor属性，该属性其实是读取原型链上的P.prototype.constructor属性
  - constructor属性可以得知某个实例对象到底是哪个构造函数产生的。

    ```js
    function F() {};
    var f = new F();

    f.constructor === F // true
    f.constructor === RegExp // false
    ```

  - constructor属性确定了实例对象f的构造函数是F,而不是RegExp.
    - 有了constructor属性，就可以从一个实例对象新建另一个实例

      ```js
      function Constr () {}
      var x =  new Constr();

      var y = new x.constructor();
      y instanceof Constr // true
      ```

- constructor属性表示原型对象与构造函数之间的关联关系，如果修改了原型对象，一般会同时修改constructor属性，防止引用的时候出错。

  ```js
  function Person (name) {
    this.name = name;
  }

  Person.prototype.constructor === Person // true

  Person.prototype = {
    method: function () {}
  };

  Person.prototype.constructor === Person // false
  Person.prototype.constructor === Object // true
  ```

- 修改原型对象时，一般要同时修改constructor属性的指向。

  ```js
  // 不推荐的写法
  C.prototype = {
    method1: function (...) {...},
    // ...
  };
  // 推荐的写法
  C.prototype = {
    constructor: C,
    method1: function (...) {...},
    // ...
  };
  // 更好的写法
  C.prototype.method1 = function (...) {...};
  ```

- 要么将constructor属性重新指向原来的函数，要么只在原型对象上添加方法，这样可以保证instanceof运算符不会失真
- 如果不能确定constructor属性是什么函数，还可以通过name属性从实例得到构造函数的名称

  ```js
  function Foo() {}
  var f = new Foo();
  f.constructor.name // "Foo"
  ```

## 2. instanceof运算符

- instanceof运算符返回一个布尔值，表示对象是否为某个构造函数的实例

  ```js
  var v = new Vehicle();
  v instanceof Vehicle // true
  ```

- instanceof运算符的左边是实例对象，右边是构造函数，它会检查右边构建函数的原型对象prototype是否在左边对象的原型链上

  ```js
  v instanceof Vehicle
  // 等同于
  Vehicle.prototype.isPrototypeOf(v)
  ```

- 由于instanceof检查整改原型链，因此同一个实例对象，可能会对多个构造函数都返回true
- instanceof原理是检查右边构造函数的prototype属性，是否在左边对象的原型链上。
  - 有一种特殊情况，就是左边对象的原型链上，只有null对象，这时instanceof判断会失真。
